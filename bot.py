import os
import logging
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext
from dotenv import load_dotenv
import yt_dlp
import asyncio
from concurrent.futures import ThreadPoolExecutor

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦ÙŠØ©
load_dotenv()

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… yt-dlp
def download_video(url):
    try:
        ydl_opts = {
            'format': 'best[ext=mp4]/best',
            'outtmpl': 'downloads/%(title)s.%(ext)s',
            'quiet': True,
            'no_warnings': True,
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            video_path = ydl.prepare_filename(info)
            
            # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ù…Ø®ØªÙ„ÙÙ‹Ø§ØŒ Ù†ØºÙŠØ±Ù‡
            if not video_path.endswith('.mp4'):
                new_path = video_path.rsplit('.', 1)[0] + '.mp4'
                os.rename(video_path, new_path)
                video_path = new_path
            
            return video_path, info.get('title', 'video')
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ†Ø²ÙŠÙ„: {e}")
        return None, None

# Ù…Ø¹Ø§Ù„Ø¬ Ø£Ù…Ø± /start
async def start(update: Update, context: CallbackContext):
    await update.message.reply_text(
        "Ù…Ø±Ø­Ø¨Ù‹Ø§! ğŸ‘‹\n"
        "Ø£Ø±Ø³Ù„ Ù„ÙŠ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ Ù…Ù† Ø£ÙŠ Ù…ÙˆÙ‚Ø¹ ÙˆØ³Ø£Ø­Ø§ÙˆÙ„ ØªÙ†Ø²ÙŠÙ„Ù‡ Ù„Ùƒ.\n"
        "Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…: YouTube, Twitter, Instagram, TikTok, ÙˆØºÙŠØ±Ù‡Ø§."
    )

# Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
async def handle_message(update: Update, context: CallbackContext):
    url = update.message.text.strip()
    
    # ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ø§Ø¨Ø·
    if not url.startswith(('http://', 'https://')):
        return
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù†ØªØ¸Ø§Ø±
    wait_msg = await update.message.reply_text("â³ Ø¬Ø§Ø±ÙŠ ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...")
    
    # ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙÙŠ Ø®Ù„ÙÙŠØ©
    loop = asyncio.get_event_loop()
    with ThreadPoolExecutor() as pool:
        video_path, video_title = await loop.run_in_executor(pool, download_video, url)
    
    if video_path and os.path.exists(video_path):
        try:
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
            await update.message.reply_video(
                video=open(video_path, 'rb'),
                caption=f"âœ… {video_title}"
            )
            await wait_msg.delete()
        except Exception as e:
            await update.message.reply_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {str(e)}")
        finally:
            # Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
            os.remove(video_path)
    else:
        await wait_msg.edit_text("âŒ Ù„Ù… Ø£Ø³ØªØ·Ø¹ ØªÙ†Ø²ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø·.")

# Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
async def error_handler(update: Update, context: CallbackContext):
    logger.error(f"Ø­Ø¯Ø« Ø®Ø·Ø£: {context.error}")
    if update and update.message:
        await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

def main():
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙƒÙ†
    TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    if not TOKEN:
        logger.error("Ù„Ù… ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªÙˆÙƒÙ†!")
        return
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ø§Ù„ØªÙ†Ø²ÙŠÙ„Ø§Øª
    os.makedirs('downloads', exist_ok=True)
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    application = Application.builder().token(TOKEN).build()
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
    application.add_error_handler(error_handler)
    
    # Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª
    logger.info("Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()